// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPTIONDATA_OPTIONDATA_H_
#define FLATBUFFERS_GENERATED_OPTIONDATA_OPTIONDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace OptionData {

struct OptionChain;
struct OptionChainBuilder;

struct OptionChainList;
struct OptionChainListBuilder;

struct OptionChain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionChainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPIRATION = 4,
    VT_SPOT_PRICE = 6,
    VT_TAU_YEARS = 8,
    VT_RFR = 10,
    VT_CALLS_STRIKE = 12,
    VT_CALLS_BID = 14,
    VT_CALLS_ASK = 16,
    VT_PUTS_STRIKE = 18,
    VT_PUTS_BID = 20,
    VT_PUTS_ASK = 22
  };
  const ::flatbuffers::String *expiration() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPIRATION);
  }
  float spot_price() const {
    return GetField<float>(VT_SPOT_PRICE, 0.0f);
  }
  float tau_years() const {
    return GetField<float>(VT_TAU_YEARS, 0.0f);
  }
  const ::flatbuffers::Vector<float> *rfr() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_RFR);
  }
  const ::flatbuffers::Vector<float> *calls_strike() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CALLS_STRIKE);
  }
  const ::flatbuffers::Vector<float> *calls_bid() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CALLS_BID);
  }
  const ::flatbuffers::Vector<float> *calls_ask() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CALLS_ASK);
  }
  const ::flatbuffers::Vector<float> *puts_strike() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_PUTS_STRIKE);
  }
  const ::flatbuffers::Vector<float> *puts_bid() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_PUTS_BID);
  }
  const ::flatbuffers::Vector<float> *puts_ask() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_PUTS_ASK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPIRATION) &&
           verifier.VerifyString(expiration()) &&
           VerifyField<float>(verifier, VT_SPOT_PRICE, 4) &&
           VerifyField<float>(verifier, VT_TAU_YEARS, 4) &&
           VerifyOffset(verifier, VT_RFR) &&
           verifier.VerifyVector(rfr()) &&
           VerifyOffset(verifier, VT_CALLS_STRIKE) &&
           verifier.VerifyVector(calls_strike()) &&
           VerifyOffset(verifier, VT_CALLS_BID) &&
           verifier.VerifyVector(calls_bid()) &&
           VerifyOffset(verifier, VT_CALLS_ASK) &&
           verifier.VerifyVector(calls_ask()) &&
           VerifyOffset(verifier, VT_PUTS_STRIKE) &&
           verifier.VerifyVector(puts_strike()) &&
           VerifyOffset(verifier, VT_PUTS_BID) &&
           verifier.VerifyVector(puts_bid()) &&
           VerifyOffset(verifier, VT_PUTS_ASK) &&
           verifier.VerifyVector(puts_ask()) &&
           verifier.EndTable();
  }
};

struct OptionChainBuilder {
  typedef OptionChain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_expiration(::flatbuffers::Offset<::flatbuffers::String> expiration) {
    fbb_.AddOffset(OptionChain::VT_EXPIRATION, expiration);
  }
  void add_spot_price(float spot_price) {
    fbb_.AddElement<float>(OptionChain::VT_SPOT_PRICE, spot_price, 0.0f);
  }
  void add_tau_years(float tau_years) {
    fbb_.AddElement<float>(OptionChain::VT_TAU_YEARS, tau_years, 0.0f);
  }
  void add_rfr(::flatbuffers::Offset<::flatbuffers::Vector<float>> rfr) {
    fbb_.AddOffset(OptionChain::VT_RFR, rfr);
  }
  void add_calls_strike(::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_strike) {
    fbb_.AddOffset(OptionChain::VT_CALLS_STRIKE, calls_strike);
  }
  void add_calls_bid(::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_bid) {
    fbb_.AddOffset(OptionChain::VT_CALLS_BID, calls_bid);
  }
  void add_calls_ask(::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_ask) {
    fbb_.AddOffset(OptionChain::VT_CALLS_ASK, calls_ask);
  }
  void add_puts_strike(::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_strike) {
    fbb_.AddOffset(OptionChain::VT_PUTS_STRIKE, puts_strike);
  }
  void add_puts_bid(::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_bid) {
    fbb_.AddOffset(OptionChain::VT_PUTS_BID, puts_bid);
  }
  void add_puts_ask(::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_ask) {
    fbb_.AddOffset(OptionChain::VT_PUTS_ASK, puts_ask);
  }
  explicit OptionChainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionChain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionChain> CreateOptionChain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> expiration = 0,
    float spot_price = 0.0f,
    float tau_years = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> rfr = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_strike = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_bid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> calls_ask = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_strike = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_bid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> puts_ask = 0) {
  OptionChainBuilder builder_(_fbb);
  builder_.add_puts_ask(puts_ask);
  builder_.add_puts_bid(puts_bid);
  builder_.add_puts_strike(puts_strike);
  builder_.add_calls_ask(calls_ask);
  builder_.add_calls_bid(calls_bid);
  builder_.add_calls_strike(calls_strike);
  builder_.add_rfr(rfr);
  builder_.add_tau_years(tau_years);
  builder_.add_spot_price(spot_price);
  builder_.add_expiration(expiration);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OptionChain> CreateOptionChainDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *expiration = nullptr,
    float spot_price = 0.0f,
    float tau_years = 0.0f,
    const std::vector<float> *rfr = nullptr,
    const std::vector<float> *calls_strike = nullptr,
    const std::vector<float> *calls_bid = nullptr,
    const std::vector<float> *calls_ask = nullptr,
    const std::vector<float> *puts_strike = nullptr,
    const std::vector<float> *puts_bid = nullptr,
    const std::vector<float> *puts_ask = nullptr) {
  auto expiration__ = expiration ? _fbb.CreateString(expiration) : 0;
  auto rfr__ = rfr ? _fbb.CreateVector<float>(*rfr) : 0;
  auto calls_strike__ = calls_strike ? _fbb.CreateVector<float>(*calls_strike) : 0;
  auto calls_bid__ = calls_bid ? _fbb.CreateVector<float>(*calls_bid) : 0;
  auto calls_ask__ = calls_ask ? _fbb.CreateVector<float>(*calls_ask) : 0;
  auto puts_strike__ = puts_strike ? _fbb.CreateVector<float>(*puts_strike) : 0;
  auto puts_bid__ = puts_bid ? _fbb.CreateVector<float>(*puts_bid) : 0;
  auto puts_ask__ = puts_ask ? _fbb.CreateVector<float>(*puts_ask) : 0;
  return OptionData::CreateOptionChain(
      _fbb,
      expiration__,
      spot_price,
      tau_years,
      rfr__,
      calls_strike__,
      calls_bid__,
      calls_ask__,
      puts_strike__,
      puts_bid__,
      puts_ask__);
}

struct OptionChainList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionChainListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAINS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<OptionData::OptionChain>> *chains() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OptionData::OptionChain>> *>(VT_CHAINS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHAINS) &&
           verifier.VerifyVector(chains()) &&
           verifier.VerifyVectorOfTables(chains()) &&
           verifier.EndTable();
  }
};

struct OptionChainListBuilder {
  typedef OptionChainList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chains(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OptionData::OptionChain>>> chains) {
    fbb_.AddOffset(OptionChainList::VT_CHAINS, chains);
  }
  explicit OptionChainListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionChainList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionChainList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionChainList> CreateOptionChainList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OptionData::OptionChain>>> chains = 0) {
  OptionChainListBuilder builder_(_fbb);
  builder_.add_chains(chains);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OptionChainList> CreateOptionChainListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<OptionData::OptionChain>> *chains = nullptr) {
  auto chains__ = chains ? _fbb.CreateVector<::flatbuffers::Offset<OptionData::OptionChain>>(*chains) : 0;
  return OptionData::CreateOptionChainList(
      _fbb,
      chains__);
}

inline const OptionData::OptionChainList *GetOptionChainList(const void *buf) {
  return ::flatbuffers::GetRoot<OptionData::OptionChainList>(buf);
}

inline const OptionData::OptionChainList *GetSizePrefixedOptionChainList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OptionData::OptionChainList>(buf);
}

inline bool VerifyOptionChainListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OptionData::OptionChainList>(nullptr);
}

inline bool VerifySizePrefixedOptionChainListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OptionData::OptionChainList>(nullptr);
}

inline void FinishOptionChainListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OptionData::OptionChainList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOptionChainListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OptionData::OptionChainList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace OptionData

#endif  // FLATBUFFERS_GENERATED_OPTIONDATA_OPTIONDATA_H_
